import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as s,f as t}from"./app-5f4e7946.js";const n="/CoderNotes/assets/image-20230825092255332-28037f2a.png",i="/CoderNotes/assets/image-20230825094527385-7ba63f5c.png",r="/CoderNotes/assets/image-20230825094758105-b0d8d6f7.png",o="/CoderNotes/assets/image-20230825095053888-d28ccc44.png",d="/CoderNotes/assets/image-20230825095710348-c0b5b87b.png",c="/CoderNotes/assets/image-20230825100319999-838d0c61.png",l="/CoderNotes/assets/image-20230825100404544-4f4d91ab.png",p="/CoderNotes/assets/image-20230825100820818-28e2c543.png",h="/CoderNotes/assets/image-20230825101230512-4d10e239.png",g="/CoderNotes/assets/image-20230825101412958-250b7bad.png",m={},u=t('<h2 id="docker镜像文件介绍" tabindex="-1"><a class="header-anchor" href="#docker镜像文件介绍" aria-hidden="true">#</a> Docker镜像文件介绍</h2><h3 id="镜像是什么" tabindex="-1"><a class="header-anchor" href="#镜像是什么" aria-hidden="true">#</a> 镜像是什么</h3><blockquote><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p></blockquote><h4 id="unionfs" tabindex="-1"><a class="header-anchor" href="#unionfs" aria-hidden="true">#</a> UnionFS</h4><p>UnionFS（联合文件系统）: Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。<br> Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。<br><img src="'+n+'" alt="" loading="lazy"></p><p><code>特性</code>：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h4 id="镜像加载原理" tabindex="-1"><a class="header-anchor" href="#镜像加载原理" aria-hidden="true">#</a> 镜像加载原理</h4><p>Docker镜像加载原理：<br> Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统叫<code>UnionFS</code>。<br><code>Bootfs(boot file system)</code>主要包含Bootloader和Kernel, Bootloader主要是引导加载Kernel, Linux刚启动时会加载Bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含Boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。<br><code>Rootfs (root file system)</code> ，在Bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。Rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p><h4 id="分层的镜像" tabindex="-1"><a class="header-anchor" href="#分层的镜像" aria-hidden="true">#</a> 分层的镜像</h4><p>其实我们前面在 pull 文件的时候比如 Tomcat，在pull界面我们就可以看到下载的文件是一层层的。</p><p>![image-20210322155748953](file:///F:/02.22%E7%89%88Docker%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8+%E5%AE%9E%E8%B7%B5/%E8%B5%84%E6%96%99/01-%E8%AF%BE%E4%BB%B6%E8%B5%84%E6%96%99/img/image-20210322155748953.png?lastModify=1692925810)</p><h4 id="分层结构的特点" tabindex="-1"><a class="header-anchor" href="#分层结构的特点" aria-hidden="true">#</a> 分层结构的特点</h4><p>其实我们也会考虑docker为什么会采用这种分层的结果，它有什么好处呢？<br> 最大的一个好处就是共享资源：<br> 比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><h4 id="镜像的特点" tabindex="-1"><a class="header-anchor" href="#镜像的特点" aria-hidden="true">#</a> 镜像的特点</h4><p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，这一层通常被称为容器层，容器层之下的都叫镜像层。</p><h3 id="镜像操作" tabindex="-1"><a class="header-anchor" href="#镜像操作" aria-hidden="true">#</a> 镜像操作</h3><p><code>docker commit -m=&quot;要提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[标签名]</code></p><p><strong>操作案例</strong>：我们通过Tomcat镜像来创建容器后操作处理，然后将容器制作为新的镜像，然后我们通过新的镜像来制作容器来演示这个效果，有点绕，我们直接通过案例来说。</p><h4 id="下载tomcat镜像" tabindex="-1"><a class="header-anchor" href="#下载tomcat镜像" aria-hidden="true">#</a> 下载tomcat镜像</h4><figure><img src="'+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="创建容器并启动" tabindex="-1"><a class="header-anchor" href="#创建容器并启动" aria-hidden="true">#</a> 创建容器并启动</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-p</span> <span class="token number">8888</span>:8080 tomcat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-p</td><td>主机端口:docker容器端口</td></tr><tr><td>-P</td><td>随机分配端口</td></tr><tr><td>-i</td><td>交互</td></tr><tr><td>-t</td><td>终端</td></tr></tbody></table><figure><img src="`+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>容器启动成功后，直接通过<code>IP:PORT</code>的形式访问此服务。</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>此时，客户端浏览器显示为404，此页面虽然显示为404，但说明我们的Tomcat服务启动起来了，那为什么会显示404呢，我们进入容器内部看一下。</p><figure><img src="'+d+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由上图可知，在Tomcat容器的webapps目录下为空，此时启动服务当然访问不到任何页面。</p><h4 id="修改容器" tabindex="-1"><a class="header-anchor" href="#修改容器" aria-hidden="true">#</a> 修改容器</h4><p>我们发现启动的容器中没有要访问的资源，那么我们自己创建对应的资源即可</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 容器ID /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>修改完成后，再次访问此服务，可以访问到页面了。<br><img src="'+l+`" alt="" loading="lazy"></p><h4 id="创建镜像" tabindex="-1"><a class="header-anchor" href="#创建镜像" aria-hidden="true">#</a> 创建镜像</h4><p>我们现在的容器和下载的有区别了，我们可以在这个基础上来创建新的镜像</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> commit <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">&#39;FrostyLunar&#39;</span> <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">&#39;add index.html&#39;</span> 容器ID frostylunar/tomcat:1.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="启动新镜像" tabindex="-1"><a class="header-anchor" href="#启动新镜像" aria-hidden="true">#</a> 启动新镜像</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-p</span> <span class="token number">8888</span>:8080 frostylunar/tomcat:1.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>启动新镜像成功后，再次访问此服务，可以直接进入此页面。</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',43),b=[u];function f(_,k){return e(),s("div",null,b)}const y=a(m,[["render",f],["__file","Docker镜像文件介绍.html.vue"]]);export{y as default};
