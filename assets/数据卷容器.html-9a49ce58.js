import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as s,f as i}from"./app-5f4e7946.js";const t="/CoderNotes/assets/image-20230825134826948-50bb4883.png",n="/CoderNotes/assets/image-20230825132210302-9b2d1de0.png",o="/CoderNotes/assets/image-20230825133758341-6497c4b7.png",r="/CoderNotes/assets/image-20230825133830045-4bc93e42.png",c="/CoderNotes/assets/image-20230825135114724-885d87aa.png",l="/CoderNotes/assets/image-20230825135132471-744ef95d.png",d="/CoderNotes/assets/image-20230825135149069-ec17ef4e.png",p="/CoderNotes/assets/image-20230825135440400-a5b60694.png",g="/CoderNotes/assets/image-20230825135453335-3366045f.png",m="/CoderNotes/assets/image-20230825135509703-aaeb4bfd.png",f="/CoderNotes/assets/image-20230825135825139-395e9b81.png",u="/CoderNotes/assets/image-20230825135836879-37d203ba.png",b={},_=i('<h2 id="数据卷容器" tabindex="-1"><a class="header-anchor" href="#数据卷容器" aria-hidden="true">#</a> 数据卷容器</h2><p>命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据的容器，称之为数据卷容器。</p><figure><img src="'+t+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="启动一个父容器" tabindex="-1"><a class="header-anchor" href="#启动一个父容器" aria-hidden="true">#</a> 启动一个父容器</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> fl01 frostylunar/centos:1.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+n+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="创建两个子容器" tabindex="-1"><a class="header-anchor" href="#创建两个子容器" aria-hidden="true">#</a> 创建两个子容器</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> fl02 --volumes-from fl01 frostylunar/centos:1.0
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> fl03 --volumes-from fl01 frostylunar/centos:1.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个子容器：<br><img src="`+o+'" alt="" loading="lazy"></p><p>第二个子容器：<br><img src="'+r+'" alt="" loading="lazy"></p><p>创建子容器完成后，我们就可以开始进行测试了：<br> 在父容器中的<code>dataVolumeContainer1</code>数据卷中创建文件test.txt，如下图所示，子容器中均可以访问到此文件。</p><p><img src="'+c+'" alt="" loading="lazy"><br><img src="'+l+'" alt="" loading="lazy"><br><img src="'+d+'" alt="" loading="lazy"></p><p>当我们在子容器1中对文件内容进行更改，则父容器和子容器2中文件的内容均进行更改。</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>注意：删除fl01后，容器fl02和fl03仍然可以进行数据共享。</p></blockquote><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>注意：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。</p></blockquote>',20),h=[_];function v(k,x){return e(),s("div",null,h)}const N=a(b,[["render",v],["__file","数据卷容器.html.vue"]]);export{N as default};
