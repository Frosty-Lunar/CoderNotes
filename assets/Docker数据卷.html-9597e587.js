import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as i,f as s}from"./app-5f4e7946.js";const t="/CoderNotes/assets/image-20230825104102115-3d0e58ff.png",n="/CoderNotes/assets/image-20230825104247389-6ce77418.png",o="/CoderNotes/assets/image-20230825104406930-c6a54cbb.png",r="/CoderNotes/assets/image-20230825104751050-4b8b7e6c.png",d="/CoderNotes/assets/image-20230825104946535-4a1917b2.png",c="/CoderNotes/assets/image-20230825105045494-4402ed80.png",l="/CoderNotes/assets/image-20230825105118456-dc7d1689.png",p="/CoderNotes/assets/image-20230825105318717-60009d0e.png",g="/CoderNotes/assets/image-20230825105839065-fa92c87b.png",f="/CoderNotes/assets/image-20230825110122059-e5e1983f.png",u="/CoderNotes/assets/image-20230825110303928-1ccdb39e.png",m="/CoderNotes/assets/image-20230825113337263-fdcde6d2.png",h="/CoderNotes/assets/image-20230825113527803-22b9643f.png",b="/CoderNotes/assets/image-20230825114131959-6b4eb91d.png",_="/CoderNotes/assets/image-20230825114415037-d1ecaa74.png",v="/CoderNotes/assets/image-20230825114436479-ee362459.png",k={},x=s(`<h2 id="docker数据卷" tabindex="-1"><a class="header-anchor" href="#docker数据卷" aria-hidden="true">#</a> Docker数据卷</h2><h3 id="数据卷" tabindex="-1"><a class="header-anchor" href="#数据卷" aria-hidden="true">#</a> 数据卷</h3><p>​前面我们介绍了镜像和容器，通过镜像我们可以启动多个容器，但是我们发现当我们的容器停止获取删除后，我们在容器中的应用的一些数据也丢失了，这时为了解决容器的数据持久化，我们需要通过容器数据卷来解决这个问题。</p><h4 id="数据卷是什么" tabindex="-1"><a class="header-anchor" href="#数据卷是什么" aria-hidden="true">#</a> 数据卷是什么</h4><p>Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据作为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了，为了能保存数据在docker中我们使用卷。简单来说，容器卷就相当于Redis中持久化方式的RDB和AOF。</p><h4 id="解决了什么问题" tabindex="-1"><a class="header-anchor" href="#解决了什么问题" aria-hidden="true">#</a> 解决了什么问题</h4><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：<br> 卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。<br> 特点：</p><ol><li>数据卷可在容器之间共享或重用数据。</li><li>卷中的更改可以直接生效。</li><li>数据卷中的更改不会包含在镜像的更新中。</li><li>数据卷的生命周期一直持续到没有容器使用它为止。</li></ol><blockquote><p>持久化，容器间继承和共享数据</p></blockquote><h4 id="数据卷使用" tabindex="-1"><a class="header-anchor" href="#数据卷使用" aria-hidden="true">#</a> 数据卷使用</h4><h5 id="直接添加" tabindex="-1"><a class="header-anchor" href="#直接添加" aria-hidden="true">#</a> 直接添加</h5><p>运行一个centos容器</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-v</span> /宿主机绝对路径:/容器内目录 镜像名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>运行此命令直接进入容器中，通过<code>ls</code>命令可以看到容器内自动创建了文件夹<code>dockerfile1</code>。</p><figure><img src="`+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在宿主机的根目录下会多出对应的文件夹</p><figure><img src="'+n+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>通过inspect命令可以查询容器的详情</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> inspect 容器ID
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h6 id="数据共享的操作" tabindex="-1"><a class="header-anchor" href="#数据共享的操作" aria-hidden="true">#</a> 数据共享的操作</h6><p>宿主机在数据卷<code>dockerfile1</code>中添加文件<code>test.txt</code>并输入内容<code>Hello World!</code>。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在容器中对应的位置<code>dockerfile1</code>中查看此文件。</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>容器中可以同步看到，然后在容器中修改数据</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>停止掉容器后，数据依然存在，实现了容器中数据的持久化保存。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h6 id="权限的修改" tabindex="-1"><a class="header-anchor" href="#权限的修改" aria-hidden="true">#</a> 权限的修改</h6><p>有时候我们想要对容器进行权限控制：不允许在容器中修改挂载的文件。</p><figure><img src="'+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>RW</code>的属性值为<code>true</code>代表容器中该目录的权限为可读写。</p><p>我们可以在启动容器的时候设置权限：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-v</span> /宿主机绝对路径:/容器目录:ro 镜像名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在容器中，文件为只读模式，可查看但是不可以修改。</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>再次通过<code>docker inspect 容器ID</code>查看容器的详细信息。此时<code>RW</code>为属性值为false，<code>Mode</code>为属性值ro，只支持读操作，不允许写操作。</p><figure><img src="'+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="dockerfile添加" tabindex="-1"><a class="header-anchor" href="#dockerfile添加" aria-hidden="true">#</a> Dockerfile添加</h5><p>宿主机目录下创建一个目录Dockerfile，并在该目录下新建一个文件<code>testContainer</code>，内容如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># volume test</span>
FROM centos
VOLUME <span class="token punctuation">[</span><span class="token string">&quot;/dataVolumeContainer1&quot;</span>,<span class="token string">&quot;/dataVolumeContainer2&quot;</span><span class="token punctuation">]</span>
CMD <span class="token builtin class-name">echo</span> <span class="token string">&quot;finished,--------successfully!&quot;</span>
CMD /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后根据此文件构建镜像：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> build <span class="token parameter variable">-f</span> testContainer <span class="token parameter variable">-t</span> frostylunar/centos:1.0 <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table><thead><tr><th style="text-align:left;"><strong>参数</strong></th><th style="text-align:left;"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:left;">-f</td><td style="text-align:left;">Dockerfile文件的路径</td></tr><tr><td style="text-align:left;">-t</td><td style="text-align:left;">标签</td></tr><tr><td style="text-align:left;">.</td><td style="text-align:left;">当前路径</td></tr></tbody></table><figure><img src="`+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>启动我们构建的镜像，并进入容器内部：</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>容器内自动创建了两个目录卷，那么这两个目录和宿主机的映射目录在哪呢？这时我们可以通过inspect命令查看。</p><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>此时创建了两个匿名容器卷，验证一下是否正确：在宿主机的该目录下创建文件，到容器中查看。</p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',54),y=[x];function C(N,z){return a(),i("div",null,y)}const M=e(k,[["render",C],["__file","Docker数据卷.html.vue"]]);export{M as default};
